<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GE Web World Planner</title>
    <style>
        :root {
            --bg-dark: #121212;
            --panel-bg: #1e1e1e;
            --accent: #3b82f6;
            --text-main: #e5e7eb;
            --border: #374151;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow-y: hidden;
            overflow-x: hidden;
        }

        h4 {
            margin: 6px 0 6px 0;
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #9ca3af;
        }

        /* UI Elements */
        .dual-control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .trip-control-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }

        select,
        button,
        input[type="text"] {
            width: 100%;
            padding: 8px;
            background: #2d2d2d;
            border: 1px solid var(--border);
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-bottom: 5px;
        }

        button {
            cursor: pointer;
            transition: 0.2s;
        }

        button:hover {
            background: #404040;
        }

        button.active {
            background: var(--accent);
            border-color: white;
            font-weight: bold;
        }

        /* Palette & Search */
        #tileSearch {
            background: #111;
            border-color: var(--accent);
            width: 90%;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            background: #111;
            padding: 8px;
            border-radius: 4px;
            max-height: 220px;
            overflow-x: hidden;
            overflow-y: scroll;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .palette img,
        .palette .color-tile {
            width: 100%;
            aspect-ratio: 1;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 2px;
        }

        .palette img.selected,
        .palette .color-tile.selected {
            border-color: var(--accent);
        }

        .color-tile {
            display: inline-block;
        }

        /* Viewport */
        .viewport {
            position: relative;
            overflow: auto;
            background: #0f0f0f;
            display: block;
            justify-content: center;
            align-items: center;

        }

        canvas {
            display: block;
            image-rendering: pixelated;
            background-color: #1a1a1a;
            justify-content: center;
            align-items: center;

        }

        .info {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--panel-bg);
            border: 2px solid var(--accent);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            max-width: 250px;
            text-align: center;
        }

        #coordDisplay {
            color: #10b981;
            font-family: monospace;
            height: 110%;
            align-self: center;
            margin: 0px;
        }

        .palette::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
    </style>
</head>

<body>

    <aside class="sidebar">
        <div class="control-group">
            <h4>Tools & Layers</h4>
            <button id="layerSelect" onclick="toggleLayer()">Block Layer</button>
            <div class="trip-control-row">
                <button id="btnBrush" onclick="setTool('brush')">Brush</button>
                <button id="btnBucket" onclick="setTool('bucket')">Fill</button>
                <button id="btnPan" class="active" onclick="setTool('pan')">Pan</button>
            </div>

            <h4>Brush Size</h4>
            <select id="brushSize">
                <option value="1">1x1</option>
                <option value="2">2x2</option>
                <option value="3">3x3</option>
                <option value="4">4x4</option>
                <option value="5">5x5</option>
            </select>
        </div>

        <div class="control-group">
            <h4>Blocks</h4>
            <input type="text" id="tileSearch" placeholder="Search tiles..." oninput="filterTiles()">
            <div id="tilePalette" class="palette"></div>
            <div class="dual-control-row" style="margin-top:5px">
                <button id="rotation" onclick="rotateTile()">Rot: 0°</button>
                <button id="mirror" onclick="flipTile()">Mirror: Off</button>
            </div>
            <button onclick="document.getElementById('tileUpload').click()">Import Custom Blocks</button>
            <input type="file" id="tileUpload" accept="image/*" multiple style="display:none">
        </div>

        <div class="control-group">
            <h4>World Settings</h4>
            <div class="dual-control-row">
                <button onclick="toggleGrid()">Toggle Grid</button>
                <button onclick="clearMap()">Clear World</button>
            </div>
            <button onclick="addBedrockLayers()">Add Bedrock Layer</button>
            <button onclick="saveAsPNG()">Save World Image</button>
            <button onclick="document.getElementById('bgUpload').click()">Set World BG Image</button>
            <input type="file" id="bgUpload" accept="image/*" style="display:none">
            <button onclick="exportMapFile()">Export World Data</button>
            <button onclick="document.getElementById('mapImport').click()">Import World Data</button>
            <input type="file" id="mapImport" accept=".map" style="display:none">
            <button onclick="exportTileList()">Export Block List</button>
            <button onclick="showInfo()">Info</button>
        </div>
        <h4 id="coordDisplay">Tile Position: (0, 0)</h4>
    </aside>

    <main class="viewport">
        <canvas id="mainCanvas"></canvas>

        <div class="info" id="myForm">
            <h4 style="color: var(--accent);">Version: 1.2</h4>
            <p style="font-size: 0.9rem; line-height: 1.4;">
                Happy Birthday to You,<br>
                Happy Birthday to You,<br>
                Happy Birthday Dear User,<br>
                Onyx update this text!
            </p>
            <h4 style="color: var(--accent);">Website by: Onyx</h4>
            <button onclick="showInfo()">Close</button>
        </div>
    </main>

    <script>
        const COLS = 100, ROWS = 60, TILE_SIZE = 32;
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const viewport = document.querySelector('.viewport');
        const coordDisplay = document.getElementById('coordDisplay');

        // State
        let mapData = { background: {}, foreground: {} };
        let history = [], redoStack = [];
        let selectedTileData = null;
        let currentLayer = "foreground";
        let clipboard = null;
        let tool = 'pan';
        let zoom = 1.00, rotation = 0, flipped = false, showGrid = true;
        let lastX = null;
        let lastY = null;
        let isInfoVisible = false; // Renamed from showInfo to avoid collision with function name
        const imgCache = {};

        //import tiles
        loadSpritesheet();

        //add bedrock
        addBedrockLayers();

        // Setup Background Image
        let bgImage = new Image();
        bgImage.src = 'backgrounds/GE_spring_background.jpg';
        bgImage.onload = () => draw();
        bgImage.onerror = () => console.log("Default background not found.");

        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        //event listeners
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('mousemove', handleInput);
        window.addEventListener('mouseup', () => { lastX = null; lastY = null; });
        canvas.oncontextmenu = (e) => e.preventDefault();

        // --- Improved Spritesheet Loader ---
        async function loadSpritesheet() {
            try {
                const response = await fetch('spritesheet.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                const spriteImg = new Image();
                spriteImg.crossOrigin = "anonymous";
                spriteImg.src = data.meta.image || 'spritesheet.png';

                // Use decode() to ensure the image is fully ready for slicing
                try {
                    await spriteImg.decode();
                } catch (e) {
                    throw new Error("Master spritesheet image could not be decoded. Ensure 'spritesheet.png' is correct.");
                }

                const palette = document.getElementById('tilePalette');
                palette.innerHTML = '';

                const tempCanvas = document.createElement('canvas');
                const tCtx = tempCanvas.getContext('2d');

                const frames = Object.entries(data.frames).sort((a, b) => a[1].index - b[1].index);

                frames.forEach(([name, info]) => {
                    const { x, y, w, h } = info.frame;
                    if (w === 0 || h === 0) return;

                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    tCtx.clearRect(0, 0, w, h);
                    tCtx.drawImage(spriteImg, x, y, w, h, 0, 0, w, h);

                    const dataUrl = tempCanvas.toDataURL();
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.title = name.replace(".png", "").replace(".jpg", "");
                    img.onclick = () => selectTile(dataUrl, img);
                    palette.appendChild(img);
                });

                console.log(`Successfully imported ${frames.length} tiles.`);
                draw();
            } catch (err) {
                console.error("Failed to load spritesheet:", err);
            }
        }

        function selectTile(src, el) {
            document.querySelectorAll('.palette img, .palette .color-tile').forEach(i => i.classList.remove('selected'));
            el.classList.add('selected');
            selectedTileData = src;
        }

        // --- Core Rendering ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Added safety check for naturalWidth to prevent "broken" state errors
            if (bgImage && bgImage.complete && bgImage.naturalWidth > 0) {
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            }

            renderLayer(mapData.background);
            renderLayer(mapData.foreground);

            if (showGrid) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                ctx.beginPath();
                for (let i = 0; i <= COLS; i++) { ctx.moveTo(i * TILE_SIZE, 0); ctx.lineTo(i * TILE_SIZE, canvas.height); }
                for (let j = 0; j <= ROWS; j++) { ctx.moveTo(0, j * TILE_SIZE); ctx.lineTo(canvas.width, j * TILE_SIZE); }
                ctx.stroke();
            }
        }

        async function renderLayer(layer) {
            for (let coord in layer) {
                const [x, y] = coord.split(',').map(Number);
                const tile = layer[coord];

                // Cache logic with safety for broken images
                if (!imgCache[tile.src]) {
                    const img = new Image();
                    img.src = tile.src;
                    try {
                        await img.decode();
                        imgCache[tile.src] = img;
                    } catch (e) {
                        console.warn("Skipping broken tile image:", tile.src);
                        continue;
                    }
                }

                const cachedImg = imgCache[tile.src];
                // Final verification before drawImage
                if (!cachedImg || cachedImg.naturalWidth === 0) continue;

                ctx.save();
                ctx.translate(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
                ctx.rotate((tile.rotation * Math.PI) / 180);
                ctx.scale(tile.flipped ? -1 : 1, 1);
                ctx.drawImage(cachedImg, -TILE_SIZE / 2, -TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
                ctx.restore();
            }
        }

        // --- Features ---
        function saveState() {
            history.push(JSON.stringify(mapData));
            if (history.length > 30) history.shift();
            redoStack = [];
        }

        function undo() {
            if (history.length > 0) {
                redoStack.push(JSON.stringify(mapData));
                mapData = JSON.parse(history.pop());
                draw();
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                history.push(JSON.stringify(mapData));
                mapData = JSON.parse(redoStack.pop());
                draw();
            }
        }

        function setTool(t) {
            tool = t;
            document.getElementById('btnBrush').classList.toggle('active', t === 'brush');
            document.getElementById('btnBucket').classList.toggle('active', t === 'bucket');
            document.getElementById('btnPan').classList.toggle('active', t === 'pan');
            canvas.style.cursor = (t === 'pan') ? 'grab' : 'crosshair';
        }

        function floodFill(startX, startY) {
            const layer = mapData[currentLayer];
            const target = layer[`${startX},${startY}`]?.src || null;
            if (target === selectedTileData) return;

            const queue = [[startX, startY]];
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const key = `${x},${y}`;
                if (x < 0 || x >= COLS || y < 0 || y >= ROWS) continue;
                if ((layer[key]?.src || null) !== target) continue;

                layer[key] = { src: selectedTileData, rotation, flipped };
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
        }

        function handleInput(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = Math.floor((e.clientX - rect.left) / (TILE_SIZE * zoom));
            const mouseY = Math.floor((e.clientY - rect.top) / (TILE_SIZE * zoom));

            if (mouseX >= 0 && mouseX < COLS && mouseY >= 0 && mouseY < ROWS) {
                const displayY = (ROWS - 1) - mouseY;
                coordDisplay.innerText = `Tile Position: (${mouseX}, ${displayY})`;
            }

            if (tool === 'pan' && e.buttons === 1) {
                canvas.style.cursor = 'grabbing';
                viewport.scrollLeft -= e.movementX;
                viewport.scrollTop -= e.movementY;
                return;
            } else if (tool === 'pan') {
                canvas.style.cursor = 'grab';
                return;
            }

            if (e.buttons !== 1 && e.buttons !== 2) {
                lastX = null;
                lastY = null;
                return;
            }

            if (e.type === 'mousedown') {
                saveState();
                lastX = mouseX;
                lastY = mouseY;
            }

            if (tool === 'bucket' && e.buttons === 1) {
                floodFill(mouseX, mouseY);
            } else {
                const dx = Math.abs(mouseX - lastX);
                const dy = Math.abs(mouseY - lastY);
                const sx = (lastX < mouseX) ? 1 : -1;
                const sy = (lastY < mouseY) ? 1 : -1;
                let err = dx - dy;

                let curX = lastX;
                let curY = lastY;

                while (true) {
                    placeBrush(curX, curY, currentLayer, e.buttons);
                    if (curX === mouseX && curY === mouseY) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; curX += sx; }
                    if (e2 < dx) { err += dx; curY += sy; }
                }
            }

            lastX = mouseX;
            lastY = mouseY;
            draw();
        }

        function placeBrush(startX, startY, layer, buttons) {
            const size = parseInt(document.getElementById('brushSize').value);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const x = startX + i;
                    const y = startY + j;
                    if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                        if (buttons === 1 && selectedTileData) {
                            mapData[layer][`${x},${y}`] = {
                                src: selectedTileData,
                                rotation,
                                flipped
                            };
                        } else if (buttons === 2) {
                            delete mapData[layer][`${x},${y}`];
                        }
                    }
                }
            }
        }

        window.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key === 'z') undo();
            if (e.ctrlKey && e.key === 'Z') redo();
            if (e.key === 'g' || e.key === 'G') toggleGrid();
        });

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            changeZoom(delta);
        }, { passive: false });

        function filterTiles() {
            const query = document.getElementById('tileSearch').value.toLowerCase();
            document.querySelectorAll('.palette img').forEach(el => {
                const name = (el.title || "").toLowerCase();
                el.style.display = name.includes(query) ? 'block' : 'none';
            });
        }

        document.getElementById('bgUpload').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => { bgImage = img; draw(); };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        };

        document.getElementById('tileUpload').onchange = (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = document.createElement('img');
                    img.src = ev.target.result;
                    img.title = file.name.replace(".png", "").replace(".jpg", "");
                    img.onclick = () => selectTile(img.src, img);
                    document.getElementById('tilePalette').appendChild(img);
                };
                reader.readAsDataURL(file);
            });
        };

        function exportMapFile() {
            const dataStr = JSON.stringify(mapData);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'world_data.map';
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById('mapImport').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const importedData = JSON.parse(ev.target.result);
                    if (importedData.background && importedData.foreground) {
                        saveState();
                        mapData = importedData;
                        draw();
                    } else {
                        alert("Invalid map file format.");
                    }
                } catch (err) {
                    alert("Error reading file: " + err.message);
                }
            };
            reader.readAsText(file);
        };

        function toggleGrid() { showGrid = !showGrid; draw(); }

        function changeZoom(delta) {
            zoom = Math.min(Math.max(0.5, zoom + delta), 10);
            canvas.style.transform = `scale(${zoom})`;
        }

        function rotateTile() {
            rotation = (rotation + 90) % 360;
            document.getElementById('rotation').innerText = `Rot: ${rotation}°`;
        }

        function flipTile() {
            flipped = !flipped;
            document.getElementById('mirror').innerText = `Mirror: ${(flipped) ? "On" : "Off"}`;
        }

        function toggleLayer() {
            layerGE = "Block"
            if (currentLayer == "foreground") {
                currentLayer = "background"
                layerGE = "BG"
            }
            else {
                currentLayer = "foreground"
                layerGE = "Block"
            }
            document.getElementById('layerSelect').innerText = `${layerGE} Layer`;
        }

        // --- Info Logic ---
        function showInfo() {
            isInfoVisible = !isInfoVisible;
            document.getElementById("myForm").style.display = (isInfoVisible) ? "block" : "none";
        }

        //addbedrocklayer has the draw() function. No need to call it again.
        function clearMap() { if (confirm("Clear?")) { saveState(); mapData = { background: {}, foreground: {} }; addBedrockLayers(); } }

        function saveAsPNG() {
            const a = document.createElement('a'); a.download = 'world_render.png';
            a.href = canvas.toDataURL(); a.click();
        }

        function exportTileList() {
            const counts = {};
            const paletteItems = document.querySelectorAll('#tilePalette > *');
            const nameLookup = {};
            paletteItems.forEach(item => {
                const src = item.src;
                if (src) nameLookup[src] = item.title;
            });

            const layers = ['background', 'foreground'];
            layers.forEach(layerName => {
                const layer = mapData[layerName];
                for (let coord in layer) {
                    const tile = layer[coord];
                    const name = (nameLookup[tile.src] || "Unknown");
                    counts[name] = (counts[name] || 0) + 1;
                }
            });

            let output = "Tiles used:\n";
            for (const [name, count] of Object.entries(counts)) {
                output += `${name} - ${count}\n`;
            }

            const blob = new Blob([output], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'used_block_list.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function addBedrockLayers() {
            saveState();
            const paletteItems = document.querySelectorAll('#tilePalette img');
            let bedrockSrc = null;

            // Search for a tile with the title "Bedrock" (case insensitive)
            paletteItems.forEach(img => {
                if (img.title.toLowerCase() === 'bedrock') {
                    bedrockSrc = img.src;
                }
            });

            if (!bedrockSrc) {
                console.log("Bedrock tile not found.");
                return;
            }

            // Fill the bottom 3 rows (57, 58, 59 in a 60-row grid)
            for (let x = 0; x < COLS; x++) {
                for (let y = ROWS - 3; y < ROWS; y++) {
                    mapData.foreground[`${x},${y}`] = {
                        src: bedrockSrc,
                        rotation: 0,
                        flipped: false
                    };
                }
            }
            draw();
            console.log("Added 3 layers of Bedrock to the bottom.");
        }
    </script>
</body>

</html>

